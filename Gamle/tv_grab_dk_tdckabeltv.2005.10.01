#!/usr/bin/perl -w
use strict;

=pod

=head1 NAME

tv_grab_dk_tdckabeltv - Grab TV listings for Denmark.

=head1 SYNOPSIS

tv_grab_dk_tdckabeltv --help

tv_grab_dk_tdckabeltv [--config-file FILE] --configure

tv_grab_dk_tdckabeltv [--config-file FILE] --check-channels

tv_grab_dk_tdckabeltv [--config-file FILE] [--output FILE]

=head1 DESCRIPTION

Output TV listings for several channels available in Denmark.  The
data comes from http://tdckabeltv.dk/?UniversID=3 (TDC). The grabber
relies on parsing HTML so it might stop working at any time.

First run B<tv_grab_dk_tdckabeltv --configure> to choose, which
channels you want to download. Then running B<tv_grab_dk_tdckabeltv>
with no arguments will output listings in XML format to standard
output.

B<--configure> Prompt for which channels,
and write the configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_dk_tdckabeltv.conf>.  This is the file written by
B<--configure> and read when grabbing.

B<--check-channels> Check to see if there are any new/removed/renamed channels

B<--output FILE> write to FILE rather than standard output.

B<--days N> grab N days.  The default is one week.

B<--offset N> start N days in the future.  The default is to start
from today.

B<--quiet> suppress the progress messages normally written to standard
error.

=head2 XMLTV IDs

The channels have names, such as "DR 1". Channel names match:

 m|[a-zA-Z /\.]|

To convert a channel name to a xmltvid we replace ' ' with '_', '/"
with '%" and '.' with '-', and append ".tdckabeltv.dk". This translation
is reversible, because the target characters aren't present in any
channel names (aren't we lucky! :-D)

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

* Johnathan Motzfeld 
  Please report bugs to the 
  http://groups.yahoo.com/group/xmltvdk/
  Yahoo group!
* who had modified Jesper Skov (jskov@zoftcorp.dk)'s tv_grab_dk
* which was based on tv_grab_nl by Guido Diepen 
* and Ed Avis (ed@membled.com) and
* tv_grab_fi by Matti Airas.

=head1 BUGS

Probably several. None known at this time. Works for me! :-D

=cut

# default language
my $LANG = 'da';

my $TDCgetURL = 'http://tdckabeltv.dk/appmanager/ktv/privat'.
  '?_nfpb=true&_pageLabel=tvguide_book&_nfls=false';
my $xmltvidSuffix = '.tdckabeltv.dk';
my $NUM_POST_RETRIES = 5;


# If you enable this, remember to delete the /tmp files sometimes. The
# GET result contains a jsessionid that times out on the tdckabeltv.dk
# site after "a while" :-D
my $debug;
# $debug = "parse";
# $debug = "sequence";
my $debugGetContentsFile = "/tmp/getcontent.html";
my $debugPostContentsFile = "/tmp/postcontent.html";

use XMLTV::Version '$Rev: 985 $';
use Getopt::Long;
use LWP::Simple ();
use HTML::TreeBuilder;
use HTML::Entities; # parse entities
use IO::File;
use URI;


use Date::Manip;
# Beware - I've seen dates like:
# Fredag d. 01 october 2004
#   and
# 00:00 01 januar 2005
# - Apparently a mix of languages!!
# Date_Init("Language=Danish","DateFormat=non-US");
Date_Init("DateFormat=non-US");

# So we'll try to translate the months from danish to english, and
# then parse them as english. Then mix-language dates *should*
# work... The missing months are spelled identically in danish and in
# english.
my %monthTranslations =
  ( 'januar' => 'january',
    'februar' => 'february',
    'marts'   => 'march',
    'maj' => 'may',
    'juni' => 'june',
    'juli' => 'july',
    'oktober' => 'october',
  );

use XMLTV;
use XMLTV::Memoize;
use XMLTV::Ask;
use XMLTV::Mode;
use XMLTV::Config_file;
# use XMLTV::TZ;
# Todo: perhaps we should internationalize messages and docs?
use XMLTV::Usage <<END
tv_grab_dk_tdckabeltv: get Danish television listings in XMLTV format
To configure    : tv_grab_dk_tdckabeltv --configure [--config-file FILE]
To grab listings: tv_grab_dk_tdckabeltv [--config-file FILE] [--output FILE]
To check chans  : tv_grab_dk_tdckabeltv --check-channels [--config-file FILE] 
END
  ;

# Use Term::ProgressBar if installed.
use constant Have_bar => eval { require Term::ProgressBar; 1 };

use LWP::UserAgent;
my $ua = LWP::UserAgent->new(keep_alive => 1,
			     timeout => 120,
			    );

my ($opt_days, $opt_offset, $opt_help, $opt_output,
    $opt_configure, , $opt_check_channels,
    $opt_config_file, $opt_quiet);
$opt_days   = 7; # default
$opt_offset = 0; # default
GetOptions('days=i'         => \$opt_days,
	   'offset=i'       => \$opt_offset,
	   'help'           => \$opt_help,
	   'configure'      => \$opt_configure,
	   'check-channels' => \$opt_check_channels,
	   'config-file=s'  => \$opt_config_file,
	   'output=s'       => \$opt_output,
	   'quiet'          => \$opt_quiet,
	  )
  or usage(0);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
usage(1) if $opt_help;

my $mode = XMLTV::Mode::mode('grab', # default
			     $opt_configure => 'configure',
			     $opt_check_channels => 'check-channels',
			    );
# File that stores which channels to download.
my $config_file
  = XMLTV::Config_file::filename($opt_config_file, 
				 'tv_grab_dk_tdckabeltv', 
				 $opt_quiet);

################################################################################
# Convert channel name to xmltvid and vice-versa
################################################################################
sub getXmltvid {
  my ($channelName) = @_;
  my $xmltvid = $channelName;
  $xmltvid =~ tr| ./|_\-%|;
  return $xmltvid . $xmltvidSuffix;
}

sub getChannelName {
  my ($xmltvid) = @_;
  my $channelName = $xmltvid;
  $channelName =~ s/$xmltvidSuffix$//;
  $channelName =~ tr|_\-%| ./|;
  return $channelName;
}

################################################################################
# If needed, get the main page to get a list of categories ("emner"),
# that we must select (we'll just select them all).
################################################################################
my $_initialGetTree;
sub getInitialGetTree {
  if (! defined $_initialGetTree) {
    print STDERR "Fetching initial info from TDC... Please wait...\n";
    my $getContent;
    if (!$debug || ! -r $debugGetContentsFile) {
      my $response = $ua->get($TDCgetURL);
      die sprintf "Get (%s) failed: %s",
	$TDCgetURL,
	  $response->status_line
	    unless ($response->is_success);
      $getContent = $response->content();
      if ($debug) {
	print STDERR "Saving $debugGetContentsFile\n";
	open O, ">$debugGetContentsFile";
	print O $getContent;
	close O;
      }
    } else {
      print STDERR "Getting from $debugGetContentsFile " . 
	"- delete it to refresh\n";
      open I, "$debugGetContentsFile";
      # Get the entire file all at once...
      $getContent = join("", <I>);
      close I;
    }
    $_initialGetTree = new HTML::TreeBuilder();
    $_initialGetTree->parse($getContent);
    $_initialGetTree->eof;
  }
  return $_initialGetTree;
}

my $_postForm;
sub getPostFormFromGetTree {
  if (! $_postForm) {
    $_postForm = getInitialGetTree()->look_down
      ('_tag' => 'form',
       'name' => 'searchActionForm'
      );
  }
  return $_postForm;
}

################################################################################
# Return the channel list
################################################################################
sub getChannelHierarchy {
  my @channelHierarchy;
  my @allChannels;

  my @menu0s = getPostFormFromGetTree()->look_down
    ('_tag' => 'div',
     'class' => 'ktv_tvguide_menu0'
    );

  my $menu0;

  # The first two are for the category - or "emne";
  $menu0 = shift @menu0s;
  $menu0->attr('id') eq 'genre_hierarchy_start'
    or die "Expected genre_hierarchy_start here";
  $menu0 = shift @menu0s;
  
  # The next two are for the complate package - Fuldpakken;
  $menu0 = shift @menu0s;
  $menu0->attr('id') eq 'fpchannel_hierarchy_start'
    or die "Expected fpchannel_hierarchy_start here";
  # This next one actually contains some stuff!!
  $menu0 = shift @menu0s;
  
  # We need to ensure that a channel isn't mentioned twice - only the
  # first place it is found will be shown.
  my %detectedChannelText;
  my %detectedChannelInput;
  # This is used for both Fuldpakken (fpchannel_hierarchy) and
  # selectorchannel_hierarchy
  my $getSubHierarchy = sub {
    my ($menu0) = @_;
    my @subHierarchy;
    my @menu1s = $menu0->look_down
      ( '_tag' => 'div',
	'class' => 'ktv_tvguide_menu1');
    while (my ($heading, $channels) = (shift @menu1s, shift @menu1s)) {
      last unless $heading and $channels;
      my $headingTitle = $heading->as_text();
      my @channels = $channels->look_down('_tag' => 'div',
					  'class' => 'ktv_tvguide_menu2');
      my @channelNameList;
      foreach my $ch (@channels) {
	my $inputName = $ch->look_down('_tag' => 'input')->attr('name')
	  or die "Expected a named input here";
	my $chName = $ch->as_text();
	# Strip of leading and trailing space
	$chName =~ s/^\s*//;
	$chName =~ s/\s*$//;
	my $xmltvid = getXmltvid($chName);
	unless ($detectedChannelText{$xmltvid} ||
		$detectedChannelInput{$inputName}
	       ) {
	  push @channelNameList, [ $xmltvid, $inputName ];
	  push @allChannels, [ $xmltvid, $inputName ];
	  $detectedChannelText{$xmltvid} = 1;
	  $detectedChannelInput{$inputName} = 1;
	} else {
	  # warn "Seen $xmltvid/$inputName before!";
	}
      }
      # The channelNameList can be empty if a subhier only contains
      # channels that are present in other packages too.
      push @subHierarchy, [ $headingTitle, \@channelNameList ]
	if (@channelNameList);
    }
    return @subHierarchy;
  };
  
  push @channelHierarchy, ['Fuldpakken', [&$getSubHierarchy($menu0)]];

  # The next two are for the complate package - Fuldpakken;
  $menu0 = shift @menu0s;
  $menu0->attr('id') eq 'selectorchannel_hierarchy_start'
    or die "Expected selectorchannel_hierarchy_start here";
  # This next one actually contains some stuff!!
  $menu0 = shift @menu0s;
  push @channelHierarchy, ['Andre Pakker', [&$getSubHierarchy($menu0)]];
  return (\@allChannels, \@channelHierarchy);
}

################################################################################
# Now extract the available days from the lines of the get result
################################################################################
sub getDays {
  my $daySelect = getPostFormFromGetTree()->look_down
    ('_tag' => 'select',
     'name' => 'tvguide_search_instancewlw-select_key:{actionForm.chosenDayOption}'
    );
  my @dayOptions = $daySelect->look_down('_tag'=>'option');
  # The first option is 'I går' - yesterday...
  shift @dayOptions;
  # The next option is 'En uge frem' - all week... But there is a limit
  # of 200 programs and a week for a channel can exceed that so we
  # won't try that.
  shift @dayOptions;
  my @days;
  foreach my $d (@dayOptions) {
    push @days, [$d->attr('value'), $d->as_trimmed_text()];
  }
  return @days;
}

################################################################################
# Now extract the categories from the lines of the get result
# The contents we're looking for look somewhat like this:
# <div style="display:block" class="ktv_tvguide_menu0">
#         <div class="ktv_tvguide_menu1"><img src="/framework/skins/ktv/images/checkbox_hierachy/p.gif" onclick="tmi(this)"><img src="/framework/skins/ktv/images/checkbox_hierachy/ckb_1.gif" onclick="tch(this);"><input type="checkbox" style="display:none" name='htmlId_Bo_e_rn' ><a href="#">Børn</a></div>
#         <div class="ktv_tvguide_menu1" style="display:none">
#                 <div class="ktv_tvguide_menu2"><img src="/framework/skins/ktv/images/checkbox_hierachy/v.gif"><img src="/framework/skins/ktv/images/checkbox_hierachy/ckb_1.gif" onclick="tch(this);"><input type="checkbox" style="display:none" name='htmlId_36' ><a href="#">Mindre børn</a></div>
################################################################################
sub getEmneCheckBoxes {
  my @emneCheckboxes = ('AlleEmner');
  my $emneDiv = getPostFormFromGetTree()->look_down
    ('_tag' => 'div',
     'class' => 'ktv_tvguide_menu0',
     # Luckily, the categories (emner) are "hidden" at first, so we can
     # distinguish this div from others.
     'style' => 'display:none'
    );
  my @emneMenu1s = $emneDiv->look_down
    ('_tag' => 'div',
     'class' => 'ktv_tvguide_menu1');
  while (@emneMenu1s) {
    my $menu1header = shift @emneMenu1s;
    my $input = $menu1header->look_down('_tag'=>'input');
    push @emneCheckboxes, $input->attr('name');
    my $menu1contents = shift @emneMenu1s;
    # The subcategories are contained herein...
    my @menu2s = $menu1contents->look_down('_tag'=>'div', 
					   'class'=> 'ktv_tvguide_menu2');
    foreach my $m (@menu2s) {
      my $input = $m->look_down('_tag'=>'input');
      push @emneCheckboxes, $input->attr('name');
    }
  }
  return @emneCheckboxes;
}

################################################################################
# Get the channels that are listed as chosen and unchosen in the config file
################################################################################
my $_firstLang;
sub getFirstLang {
  getConfiguration();
  return $_firstLang;
}

my $_creditsInDesc;
sub getCreditsInDesc {
  getConfiguration();
  return $_creditsInDesc;
}
my (@_chosen, @_unchosen);
sub getChannelConfiguration {
  getConfiguration();
  return (\@_chosen, \@_unchosen);
}

sub getConfiguration {
  # Use $_firstLang to keep track of whether we've read the config file.
  unless ($_firstLang) {
    open I, $config_file
      or die "Couldn't open $config_file for reading";
    my $firstLangLine = <I>;
    $firstLangLine =~ /^firstLang=(Original|Danish)$/
      or die "Unexpected /^firstLang=(Original|Danish)\$/ line in line 1 of $config_file";
    $_firstLang = $1;
    my $creditsInDescLine = <I>;
    $creditsInDescLine =~ /^creditsInDesc=(Yes|No)$/
      or die "Unexpected /^creditsInDesc=(Yes|No)$/ line in line 1 of $config_file";
    $_creditsInDesc = (lc $1 eq 'yes') ? 1 : 0;
    while (<I>) {
      /^(# )?(.*)/;
      my ($commentedOut, $xmltvid) = ($1, $2);
      if ($commentedOut) {
	push @_unchosen, $xmltvid;
      } else {
	push @_chosen, $xmltvid;
      }
    }
    close I;
  }
}

sub checkChannelConfiguration {
  my ($chosen, $unchosen) = getChannelConfiguration();
  my %chosen = map { $_ => 1 } @$chosen;
  my %unchosen = map { $_ => 1 } @$unchosen;
  my @missingInConfFile;
  my ($allChannels, $hierarchy) = getChannelHierarchy();
  foreach my $set (@$allChannels) {
    my ($xmltvid, $input) = @$set;
    my $found = 0;
    if ($chosen{$xmltvid}) {
      delete $chosen{$xmltvid};
    } elsif ($unchosen{$xmltvid}) {
      delete $unchosen{$xmltvid};
    } else {
      push @missingInConfFile, $xmltvid;
    }
  }
  my $error;
  if (@missingInConfFile) {
    print STDERR "**Error**: Missing in configuration file:\n";
    print STDERR map { "$_\n" } @missingInConfFile;
    $error = 1;
  }
  if (keys %chosen || keys %unchosen) {
    print STDERR "**Error**: No longer in Channel lineup:\n";
    print STDERR map { "$_\n" } keys %chosen, keys %unchosen;
    $error = 1;
  }
  return $error;
}
################################################################################
# Extract the POST url (including the jsessionid that presumably
# varies from invocation to invocation...)
################################################################################
sub getPostURL {
  return getPostFormFromGetTree()->attr('action');
}



################################################################################
# Does the user want to configure or to actually fetch something?
################################################################################
if ($mode eq 'configure') {
  XMLTV::Config_file::check_no_overwrite($config_file);
  open(CONF_FILE, ">$config_file") or die "cannot write to $config_file: $!";
  my $firstLang = ask_choice
    ("Place titles of which language first in program listings",
     "Original",
     "Original", "Danish");
  
  print CONF_FILE "firstLang=$firstLang\n";
  
  my $creditsInDesc = ask_boolean
    ("Include credits in description (good for MythTV!)",1);
  
  printf CONF_FILE "creditsInDesc=%s\n",
     ($creditsInDesc) ? "Yes" : "No";
  my ($allChannels, $hierarchy) = getChannelHierarchy();
  foreach my $hier (@$hierarchy) {
    my ($hierName, $hierSubs) = @$hier;
    my $useHier = ask_choice("Channels from $hierName?",
			      "Some",
			      "Some",
			      "All",
			      "None");
    foreach my $sectionHier (@$hierSubs) {
      my ($section, $channels) = @$sectionHier;
      my $useSection;
      if ($useHier eq 'Some') {
	$useSection = ask_choice
	  ("  Channels from $hierName/$section?",
	   "Some",
	   "Some",
	   "All",
	   "None"
	   ); 
      } else {
	$useSection = $useHier;
      }
      foreach my $ch (@$channels) {
	my ($xmltvid, $id) = @$ch;
	my $channelName = getChannelName($xmltvid);
	my $useChannel;
	if ($useSection eq 'Some') {
	  $useChannel = ask_boolean
	    ("    Channel $hierName/$section: $channelName?", 1); 
	} else {
	  $useChannel = ($useSection eq 'All') ? 1 : 0;
	}
	my $prefix = ($useChannel) ? "" : "# ";
	print CONF_FILE "${prefix}$xmltvid\n";
      }
    }
  }
  close CONF_FILE;
  print STDERR "\n\n$config_file written\n";
  print STDERR "Feel free to edit it by hand if you dare... :-D\n";
  exit;
} elsif ($mode ne 'grab' && $mode ne 'check-channels') {
  die "Don't know about mode $mode";
}

my $channelError = checkChannelConfiguration();

# If we're just checking the channels, we're done.
if ($mode eq 'check-channels') {
  if ($channelError) {
    print STDERR "*Fail*: Channel configuration is not up-to-date\n";
  } else {
    print STDERR "Pass: Channel configuration is up-to-date\n";
  }
  exit ($channelError ?  1 : 0);
}
# Otherwise....

################################################################################
################################################################################
#
# The rest of the file is for grabbing...
#
################################################################################

sub getProgramsOnPage {
  my ($programDivContents) = @_;
  my $post = HTML::TreeBuilder->new();
  $post->parse($programDivContents);
  $post->eof;

  my $mainDiv = $post->look_down('_tag'=>'div', 
				 'class'=>'ktv_portlet_theme_list_10px_border');
  die "Why didn't we find a ktv_portlet_theme_list_10px_border here?"
    unless $mainDiv;

  # Now, lets go through this mainDiv.

  # All programs are contained in their own table. There are some
  # contents that are not programs, and they are not in tables.

  my @mainContents = $mainDiv->content_list();
  #######################################
  # Main Contents contains the programs of the page
  #
  # Each program starts with a table, and then it may or may not be
  # followed by a div containing program details. After the table or
  # the optional div there is a script element.
  #
  # After the very last program, there is an empty table
  #######################################
  # > 1 to avoid looking at the last bogus table - lets not look at
  # it, but just skip it.
  my $dayStr;
  my @programs;
  my @detailsFieldSequence = ( 'Orig. titel',
			       'Varighed',
			       'Oprindelse',
			       'År',
			       'Instruktør',
			       'Medvirkende' );

  while (scalar @mainContents > 1) {
    # Lets first find the table, the optional div and make sure the
    # script is there. We don't need the script for anything though.
    my ($table, $detailsDiv);
    {
      $table = shift  @mainContents;
      die "Why wasn't this a table"
	unless $table->tag() eq 'table';
      # Lets see if this program has some details in a (default hidden)
      # div
      {
	my $divMaybe = $mainContents[0];
	if ($divMaybe && $divMaybe->tag() eq 'div') {
	  $detailsDiv = shift @mainContents;
	}
      }
      # Now, we either expect to find that there is a script following
      # the table containing the program's info, and an optional div
      # containing the program details.
      my $script = shift @mainContents;
      die "Expected a script element here"
	unless $script && $script->tag() eq 'script';
    }

    # Now, lets extract the program info from the table and optional
    # div.

    # Lets first see if we are at a new day. If so, setup dayStr
    # accordingly.
    my $dayTD = $table->look_down(class=>'ktv_portlet_list_text_header');
    if ($dayTD) {
      # Yup - a new day
      $dayStr = $dayTD->as_text();
      $dayStr =~ s/.*d\. //
	or die "Expected to find a string like " .
	  "\"Torsdag d. 23 september 2004\" here";
      foreach my $danish (keys %monthTranslations) {
	$dayStr =~ s/$danish/$monthTranslations{$danish}/i;
      }
    }

    my %prog;

    my ($timeTD, $danishTitleTD) = $table->look_down
      ('class'=>'ktv_portlet_list_text_subheader_no_border');
    my ($dummy, $categoryTD) = $table->look_down
      ('class'=>'ktv_portlet_list_text_body_no_border');
    $timeTD && $danishTitleTD && $dummy && $categoryTD
      or die "Missing timeSpec, title or category of a program";

    my $timeStr = $timeTD->as_text();
    
    $timeStr =~ /^(\d\d:\d\d) -(\d\d:\d\d)$/
      or die "Unexpected format for program time: '$timeStr'";
    my ($startStr, $stopStr) = ($1, $2);
    foreach my $s (\$startStr, \$stopStr) {
      $$s .= " $dayStr";
    }
    my $startTime = UnixDate(ParseDate($startStr), "%s");
    if (!$startTime) {
      die "Unexpected start time: '$startStr'";
    }
      my $stopTime = UnixDate(ParseDate($stopStr), "%s");
    if (!$startTime) {
      die "Unexpected stop time: '$stopStr'";
    }
    # Did we pass midnight?
    $stopTime += 24*60*60
      if ($stopTime < $startTime);
    $prog{start}=UnixDate(ParseDateString("epoch $startTime"),"%q");
    $prog{stop}=UnixDate(ParseDateString("epoch $stopTime"),"%q");
    
    $prog{danishTitle} = $danishTitleTD->as_text();
    $prog{danishTitle} =~ s/^ *//;
    $prog{danishTitle} =~ s/ *$//;

    $prog{category} = $categoryTD->as_text();
    $prog{category} =~ s/.*\((.*)\)$/$1/;
    
    # Now lets look at the div
    if ($detailsDiv) {
      my $table = [$detailsDiv->content_list()]->[0];
      my ($descrTR, $detailsTR) = $table->content_list();

      # Handle the description:

      $prog{desc} = $descrTR->as_trimmed_text();
      delete $prog{desc} 
	if $prog{desc} && $prog{desc} eq '';

      # And the other fields: $detailsTR, now contains a single td,
      # that contains a table, with a number of rows. The first of
      # these rows is empty, and is discarded. The next rows all
      # contain two td-s one with a setting, and one with a value. The
      # Setting td-s are all the same and in the same sequence for all
      # programs, given in @detailsFieldSequence above:

      my $detailsTD = [$detailsTR->content_list()]->[0];
      my $detailsTable = [$detailsTD->content_list()]->[0];
      my @detailsRows = $detailsTable->content_list();
      # Discard first empty row
      shift @detailsRows;
      my $rowNum = 0;
      foreach my $row (@detailsRows) {
	my ($settingTD, $valueTD) = $row->content_list();
	my $setting = $settingTD->as_trimmed_text();
	die "Unexpected field sequence"
	  if $setting ne $detailsFieldSequence[$rowNum];
	# These settings have a sequence of links to IMDB. Only the
	# text of the link is relevant.
	if ($setting eq 'Orig. titel' ||
	    $setting eq 'Instruktør' ||
	    $setting eq 'Medvirkende') {
	  my @links = $valueTD->content_list();
	  my @values;
	  foreach my $l (@links) {
	    # We're not interested in text sections...
	    next
	      if ref($l) eq "";
	    my $val = $l->as_text();
	    push @values, $val
	      if ($val ne '');
	  }
	  if ($setting eq 'Orig. titel') {
	    $prog{info}{origTit} = $values[0]
	      if ($values[0]);
	  } elsif ($setting eq 'Instruktør') {
	    if ($values[0]) {
	      $prog{info}{inst} = $values[0];
	      # For some reason the director has a '.' appended to his name...
	      $prog{info}{inst} =~ s/\.$//;
	    }
	  } elsif ($setting eq 'Medvirkende') {
	    $prog{info}{medv} = \@values
	      if (@values);
	  } else {
	    die "Huh? Internal logic weirdness - missing case";
	  }
	} elsif ($setting eq 'År') {
	  my $year = $valueTD->as_trimmed_text();
	  if ($year) {
	    if ($year =~ /^\d{4}$/) {
	      $prog{year} = $year;
	    } else {
	      print STDERR 
		"Weird year: $year for program starting $prog{start}\n";
	    }
	  }
	}
	$rowNum++;
      }

      if (getCreditsInDesc()) {
	if ($prog{info}{inst}) {
	  $prog{desc} .= " Inst: " . $prog{info}{inst};
	}
	if ($prog{info}{medv}) {
	  $prog{desc} .= " Medv: " . join(", ", @{$prog{info}{medv}});
	}
	# We may have prepended a ' '...
	$prog{desc} =~ s/^ *//
	  if $prog{desc};
      }
    }
    push @programs, \%prog
  }
  $post->delete;
  return @programs;
}

sub convertProgramToXMLTV {
  my ($p, $chanID) = @_;
  my @titles;
  if ($$p{info}{origTit}) {
    push @titles, [$$p{info}{origTit}];
  }
  push @titles, [$$p{danishTitle}, $LANG];

  if (scalar @titles == 2 && getFirstLang() eq 'Danish') {
    @titles = reverse @titles;
  }

  my $x = { 'channel' => $chanID,
	    'title' => \@titles,
	  };
  foreach (qw(start stop)) {
    $$x{$_} = $$p{$_}
      if $$p{$_};
  }

  foreach (qw(desc category)) {
    $$x{$_} = [[$$p{$_},$LANG]]
      if $$p{$_};
  }

  if ($$p{info}{medv}) {
    $$x{credits}{actor}=$$p{info}{medv};
  }
  if ($$p{info}{inst}) {
    $$x{credits}{director}=[$$p{info}{inst}];
  }

  $$x{date} = $$p{year}
    if ($$p{year});

  return $x;
}


################################################################################
# Assemble the POST parameters
################################################################################
my @globalPostParams = 
  ( 
   [ 'tvguide_search_instancewlw-select_key:'.
     '{actionForm.chosenTimeSpanOption}', 0 ],
   [ 'tvguide_search_instance{actionForm.chosenSortOption}', 0 ]
  );

push @globalPostParams, map { [ $_, 'on' ] } getEmneCheckBoxes();

my ($allChannels) = getChannelHierarchy();
my %channelIDs;
foreach my $set (@$allChannels) {
  my ($xmltvid, $htmlid) = @$set;
  $channelIDs{$xmltvid}=$htmlid;
}

my ($chosen, $unchosen) = getChannelConfiguration();

# Make sure there are no chosen cannels, that no longer are in the
# channel hierarchy.
my @chosenInLineup;
foreach my $xmltvid (@$chosen) {
  if ($channelIDs{$xmltvid}) {
    push @chosenInLineup, $xmltvid;
  } else {
    print STDERR "Skipping chosen channel $xmltvid - no longer in lineup\n";
  }
}

my $writer;

unless ($debug && $debug eq "sequence") {
  my %writer_args;
  if (defined $opt_output) {
    my $fh = new IO::File(">$opt_output");
    die "cannot write to $opt_output: $!" if not defined $fh;
    $writer_args{OUTPUT} = $fh;
  }
  $writer_args{encoding} = 'ISO-8859-1';
  $writer = new XMLTV::Writer(%writer_args);

  # TODO: standardize these things between grabbers.
  $writer->start
    ({ 'source-info-url'     => $TDCgetURL,
       'source-data-url'     => $TDCgetURL,
       'generator-info-name' => 'XMLTV',
       'generator-info-url'  => 'http://membled.com/work/apps/xmltv/',
     });
  foreach my $name (@chosenInLineup) {
    $writer->write_channel({ 'id' => $name,
			     'display-name' => [[$name]] });
  }
}

my @days = getDays();
my $total = scalar (@chosenInLineup) * scalar (@days);
my $i = 1;
CH: foreach my $channelName (@chosenInLineup) {
  my $channelDisp = $channelName;
  $channelDisp =~ s/$xmltvidSuffix//;
  foreach my $day (@days) {
    my ($dayVal, $dayDisp) = @$day;
    # my ($dayVal, $dayDisp) = @$day;
    printf STDERR "Getting channel: %-31s ".
      # "($channelIDs{$channelName}) " .
      "for: %-9s (%3d/$total = %3.0f%%)\n",
	$channelDisp, $dayDisp, $i,
	  100 * $i / $total;
    $i++;

    next 
      if ($debug && $debug eq "sequence");
    my @postLines;
    
    # This regexp needs to be present in the post output for us to be
    # sure we have the entire file. Unfortunately, we sometimes see
    # incomplete POST results from TDC's server...
    my $divEndRegex = qr|^<div style="position: absolute; visibility: hidden; top: 0px; left: 0px; display: none"><!-- INSTADIA SCRIPT BLOCK BEGIN -->|m;

    if ($debug and $debug eq "parse" && -e $debugPostContentsFile) {
      print STDERR "Faking it - reading post data from " .
	"$debugPostContentsFile\n";
      open I,"$debugPostContentsFile"
	or die "Huh?";
      @postLines = <I>;
      close I;
    } else {
      my @postParams = @globalPostParams;
    
      push @postParams, 
	[ 'tvguide_search_instancewlw-select_key:{actionForm.chosenDayOption}',
	  $dayVal ];
      push @postParams, [$channelIDs{$channelName},'on'];
    
      my @lwpPostParams;
      foreach my $set (@postParams) {
	my ($k, $v) = @$set;
	push @lwpPostParams, $k, $v;
      }

      my $remainingRetries = $NUM_POST_RETRIES;
      
      while (! @postLines && $remainingRetries--) {
	my $postResponse = $ua->post
	  (getPostURL(), 
	   \@lwpPostParams, 
	  );
	if (! $postResponse->is_success) {
	  print STDERR sprintf "Post failed: %s\nRetrying...\n",
	      $postResponse->status_line;
	  next;
	}
	my $content = $postResponse->content();
	# my $postContentFile = "/tmp/p.html";
	# if ($postContentFile) {
	#   open O, ">", $postContentFile
	#     or die "Couldn't open $postContentFile";
	#   print O $content;
	#   close O;
	# }
	if ($content !~ /$divEndRegex/) {
	  print STDERR "Post failed: Didn't contain expected content\n" .
	    "Retrying...\n";
	  next;
	}
	if ($debug && $debug eq "parse" && ! -e "$debugPostContentsFile") {
	  open O,">$debugPostContentsFile"
	    or die "Huh?";
	  print O $postResponse->content();
	  close O;
	  print STDERR "Wrote $debugPostContentsFile\n";
	}
	@postLines = split("\n", $postResponse->content());
      }
      die "Couldn't get good data even after $NUM_POST_RETRIES retries"
	unless (@postLines);
    }
    
    # Somewhere in the post contents, there are a set of lines like this:
    #
    # <div class="ktv_portlet_container">
    #     
    # 	All program info is in this div!
    # 
    # </div>
    # <div style="position: absolute; visibility: hidden; top: 0px; left: 0px; display: none"><!-- INSTADIA SCRIPT BLOCK BEGIN -->
    #
    # Taking out that (first) div so only *it* gets parsed speeds this
    # script up so it runs in about 50% of the time... Lets do that.
    
    my @divPostLines;
    while (defined $postLines[0] && 
	   $postLines[0] !~ m|<div class="ktv_portlet_container">|) {
      shift @postLines;
    }
    while (defined $postLines[0] && $postLines[0] !~ /$divEndRegex/) {
      push @divPostLines, shift @postLines;
    }

    my $programDivContents = join ("", @divPostLines);
    foreach (getProgramsOnPage($programDivContents)) {
      $writer->write_programme(convertProgramToXMLTV($_, $channelName));
    }
    if ($debug && $debug eq "parse") {
      print STDERR "Finishing early due to debugging the parsing\n";
      # ask_boolean("Exit",1);	
      last CH;
    }
  }
}
unless ($debug && $debug eq "sequence") {
  $writer->end();
}
